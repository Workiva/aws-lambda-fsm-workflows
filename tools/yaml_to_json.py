#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# Copyright 2016-2020 Workiva Inc.
#
# Licensed under the Apache License, Version 2.0 (the 'License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# system imports
from __future__ import print_function
import argparse
import json

# library imports

# application imports
from aws_lambda_fsm.config import get_current_configuration
from aws_lambda_fsm.constants import CONFIG
from aws_lambda_fsm.serialization import json_dumps_additional_kwargs

# setup the command line args
parser = argparse.ArgumentParser(description='Turns an fsm.yaml file into an AWS Step Function json definition.')
parser.add_argument('--machine_name')
parser.add_argument('--lambda_arn')
args = parser.parse_args()


def output_machine_dict(machine_dict):
    """
    Outputs a https://states-language.net/spec.html compliant JSON text
    representing an FSM.

    :param machine_dict: a dict with machine info.
    :return: a dict.
    """

    data = {
        'Comment': 'Generated by: yaml_to_json.py --machine_name=%s' % args.machine_name,
        'States': {}
    }
    for state_dict in machine_dict.get(CONFIG.STATES, []):
        transitions = state_dict.get(CONFIG.TRANSITIONS, [])
        state_name = state_dict[CONFIG.NAME]
        choices_state_name = state_name + '-choices'

        if state_dict.get(CONFIG.INITIAL):
            data['StartAt'] = state_name

        data['States'][state_name] = {
            'Type': 'Task',
            'Resource': args.lambda_arn,
            'Retry': [
                {
                    "ErrorEquals": ["States.ALL"],
                    "IntervalSeconds": 1,
                    "MaxAttempts": int(machine_dict.get(CONFIG.MAX_RETRIES, CONFIG.DEFAULT_MAX_RETRIES)),
                    "BackoffRate": 2.0
                }
            ]
        }

        if state_dict.get(CONFIG.FINAL):
            data['States'][state_name]['End'] = True
            continue

        data['States'][state_name]['Next'] = choices_state_name

        data['States'][choices_state_name] = {
            'Type': 'Choice',
            'Choices': []
        }

        for transition_dict in transitions:
            choice = {
                'StringEquals': transition_dict[CONFIG.EVENT],
                'Variable': '$.system_context.current_event',
                'Next': transition_dict[CONFIG.TARGET]
            }
            data['States'][choices_state_name]['Choices'].append(choice)

    return data


def search_for_machine(filename='fsm.yaml'):
    """
    Searches the .yaml hierarchy for the correct machine.

    :param filename: a path to a fsm.yaml file
    :return:
    """

    for machine_dict in get_current_configuration(filename=filename)[CONFIG.MACHINES]:
        if CONFIG.IMPORT in machine_dict:
            search_for_machine(filename=machine_dict[CONFIG.IMPORT])
            continue
        if machine_dict[CONFIG.NAME] == args.machine_name:
            data = output_machine_dict(machine_dict)
            print(json.dumps(data, indent=2, **json_dumps_additional_kwargs()))
            return

# find the machine in the machine list
search_for_machine()
